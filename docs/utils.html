<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>tera.utils API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tera.utils</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#utils 
from SPARQLWrapper import SPARQLWrapper, JSON
from functools import wraps
from rdflib import Literal
from collections import defaultdict

nan_values = [&#39;nan&#39;, float(&#39;nan&#39;),&#39;--&#39;,&#39;-X&#39;,&#39;NA&#39;,&#39;NC&#39;,-1,&#39;&#39;,&#39;sp.&#39;, -1,&#39;sp,&#39;,&#39;var.&#39;,&#39;variant&#39;,&#39;NR&#39;]

def tanimoto(fp1, fp2):
    &#34;&#34;&#34;
    Calculate tanimoto similarity between two chemical fingerprints.
    Args:
        fp1 : str \n
            Chemical fingerprint on binary form.\n
        fp2 : str \n
            Chemical fingerprint on binary form.\n
    Return:
        simiarity : float
    &#34;&#34;&#34;
    fp1_count = fp1.count(&#39;1&#39;)
    fp2_count = fp2.count(&#39;1&#39;)
    both_count = (fp1 &amp; fp2).count(&#39;1&#39;)
    return float(both_count) / (fp1_count + fp2_count - both_count)


def test_endpoint(endpoint):
    &#34;&#34;&#34;
    Test SPARQL endpoint.
    Args:
        endpoint : str \n
            SPARQL endpoint URL. ex: https://query.wikidata.org/sparql \
    Return:
        bool \n
            If endpoint returns data.
    &#34;&#34;&#34;
    sparql = SPARQLWrapper(endpoint)
    q = &#34;&#34;&#34;
        SELECT ?s ?p ?o
        WHERE {?s ?p ?o}
        LIMIT 100
    &#34;&#34;&#34; 

    sparql.setQuery(q)
    sparql.setReturnFormat(JSON)
    try:
        results = sparql.query().convert()
        return True
    except:
        return False
    
    
def query_endpoint(endpoint, q, var = &#39;p&#39;):
    &#34;&#34;&#34;
    Wrapper for quering SPARQL endpoint with SPARQLWrapper.
    Args:
        endpoint : str\n
            SPARQL endpoint URL. \n
        q : str \n
            SPARQL query. \n
        var : str or list \n
            Query variables to return.
    Return:
        set \n
            Set of tuple query results. Tuple in order specified in input var. 
    &#34;&#34;&#34;
    if not isinstance(var, list):
        var = [var]
        
    sparql = SPARQLWrapper(endpoint)
    
    out = {}
    try:
        sparql.setQuery(q)
        sparql.setReturnFormat(JSON)
        results = sparql.query().convert()
        for v in var:
            try:
                out[v] = [r[v][&#39;value&#39;] for r in results[&#39;results&#39;][&#39;bindings&#39;]]
            except KeyError:
                out[v] = [None] * len(results[&#39;results&#39;][&#39;bindings&#39;])
        return set(zip(*[out[k] for k in out]))
    except Exception as e:
        print(e.message)
        return set()


def query_graph(graph, q):
    &#34;&#34;&#34;
    Query rdflib.Graph. 
    Args:
        graph : rdflib.Graph \n
        q : str \n
            SPARQL query
    Return:
        set \n
            Query results.
    &#34;&#34;&#34;
    try:
        return set(graph.query(q))
    except Exception as e:
        print(e.message)
        return set()
    

def prefixes(initNs):
    &#34;&#34;&#34;
    Format prefixes for SPARQL. 
    Args:
        initNs : dict \n
        ex : {&#39;ex&#39;:&#39;http://example.org&#39;} 
    Return:
        str \n
        SPARQL formatted prefixes.
    &#34;&#34;&#34;
    q = &#39;&#39;
    for k,i in initNs.items():
        q += &#34;PREFIX\t&#34;+k+&#39;:\t&#39; + &#39;&lt;&#39;+str(i)+&#39;&gt;\n&#39;
    return q

def strip_namespace(string, var = [&#39;/&#39;]):
    &#34;&#34;&#34;
    Remove namespace from URI.
    Args:
        string : str \n
            URI \n
        var : str or list \n
            Symbols to split string. ex. / or #.
    Return:
        str \n
            Shortest remaining string after var.
    &#34;&#34;&#34;
    if not isinstance(var,list):
        var = [var]
    tmp1 = str(string)
    for v in var:
        tmp2 = str(string).split(v)[-1]
        if len(tmp2) &lt; len(tmp1):
            tmp1 = tmp2
    return tmp1


def do_recursively_in_class(func):
    &#34;&#34;&#34;Enables function to take either element or iterable as input.&#34;&#34;&#34;
    @wraps(func)
    def call_recursively(my_class_instance, x, **kwargs):
        if isinstance(x, (list,set,tuple)):
            return {j: func(my_class_instance, j, **kwargs) for j in x}
        else:
            return func(my_class_instance, x, **kwargs)
        
    return call_recursively


def graph_to_dict(graph):
    &#34;&#34;&#34;
    Map entities in graph to a dict.
    Args:
        graph : rdflib.Graph
    Return:
        dict \n
        On the form {entity : list of literals connected to entity}
    &#34;&#34;&#34;
    entities = graph.subjects()
    d = defaultdict(list)
    
    for e in entities:
        d[e] = [str(o) for o in graph.objects(subject=e) if isinstance(o,Literal)]
    return d</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tera.utils.do_recursively_in_class"><code class="name flex">
<span>def <span class="ident">do_recursively_in_class</span></span>(<span>func)</span>
</code></dt>
<dd>
<section class="desc"><p>Enables function to take either element or iterable as input.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_recursively_in_class(func):
    &#34;&#34;&#34;Enables function to take either element or iterable as input.&#34;&#34;&#34;
    @wraps(func)
    def call_recursively(my_class_instance, x, **kwargs):
        if isinstance(x, (list,set,tuple)):
            return {j: func(my_class_instance, j, **kwargs) for j in x}
        else:
            return func(my_class_instance, x, **kwargs)
        
    return call_recursively</code></pre>
</details>
</dd>
<dt id="tera.utils.graph_to_dict"><code class="name flex">
<span>def <span class="ident">graph_to_dict</span></span>(<span>graph)</span>
</code></dt>
<dd>
<section class="desc"><p>Map entities in graph to a dict.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>rdflib.Graph</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="return">Return</h2>
<p>dict </p>
<p>On the form {entity : list of literals connected to entity}</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def graph_to_dict(graph):
    &#34;&#34;&#34;
    Map entities in graph to a dict.
    Args:
        graph : rdflib.Graph
    Return:
        dict \n
        On the form {entity : list of literals connected to entity}
    &#34;&#34;&#34;
    entities = graph.subjects()
    d = defaultdict(list)
    
    for e in entities:
        d[e] = [str(o) for o in graph.objects(subject=e) if isinstance(o,Literal)]
    return d</code></pre>
</details>
</dd>
<dt id="tera.utils.prefixes"><code class="name flex">
<span>def <span class="ident">prefixes</span></span>(<span>initNs)</span>
</code></dt>
<dd>
<section class="desc"><p>Format prefixes for SPARQL. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>initNs</code></strong> :&ensp;<code>dict</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>ex</code></strong> :&ensp;{<code>'ex'</code>:<code>'http</code>://<code>example.org'</code>}</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="return">Return</h2>
<p>str </p>
<p>SPARQL formatted prefixes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prefixes(initNs):
    &#34;&#34;&#34;
    Format prefixes for SPARQL. 
    Args:
        initNs : dict \n
        ex : {&#39;ex&#39;:&#39;http://example.org&#39;} 
    Return:
        str \n
        SPARQL formatted prefixes.
    &#34;&#34;&#34;
    q = &#39;&#39;
    for k,i in initNs.items():
        q += &#34;PREFIX\t&#34;+k+&#39;:\t&#39; + &#39;&lt;&#39;+str(i)+&#39;&gt;\n&#39;
    return q</code></pre>
</details>
</dd>
<dt id="tera.utils.query_endpoint"><code class="name flex">
<span>def <span class="ident">query_endpoint</span></span>(<span>endpoint, q, var='p')</span>
</code></dt>
<dd>
<section class="desc"><p>Wrapper for quering SPARQL endpoint with SPARQLWrapper.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>endpoint</code></strong> :&ensp;<code>str</code></dt>
<dd>SPARQL endpoint URL.</dd>
<dt><strong><code>q</code></strong> :&ensp;<code>str</code></dt>
<dd>SPARQL query.</dd>
<dt><strong><code>var</code></strong> :&ensp;<code>str</code> or <code>list</code></dt>
<dd>Query variables to return.</dd>
</dl>
<h2 id="return">Return</h2>
<p>set </p>
<pre><code>Set of tuple query results. Tuple in order specified in input var.
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def query_endpoint(endpoint, q, var = &#39;p&#39;):
    &#34;&#34;&#34;
    Wrapper for quering SPARQL endpoint with SPARQLWrapper.
    Args:
        endpoint : str\n
            SPARQL endpoint URL. \n
        q : str \n
            SPARQL query. \n
        var : str or list \n
            Query variables to return.
    Return:
        set \n
            Set of tuple query results. Tuple in order specified in input var. 
    &#34;&#34;&#34;
    if not isinstance(var, list):
        var = [var]
        
    sparql = SPARQLWrapper(endpoint)
    
    out = {}
    try:
        sparql.setQuery(q)
        sparql.setReturnFormat(JSON)
        results = sparql.query().convert()
        for v in var:
            try:
                out[v] = [r[v][&#39;value&#39;] for r in results[&#39;results&#39;][&#39;bindings&#39;]]
            except KeyError:
                out[v] = [None] * len(results[&#39;results&#39;][&#39;bindings&#39;])
        return set(zip(*[out[k] for k in out]))
    except Exception as e:
        print(e.message)
        return set()</code></pre>
</details>
</dd>
<dt id="tera.utils.query_graph"><code class="name flex">
<span>def <span class="ident">query_graph</span></span>(<span>graph, q)</span>
</code></dt>
<dd>
<section class="desc"><p>Query rdflib.Graph. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>rdflib.Graph</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>q</code></strong> :&ensp;<code>str</code></dt>
<dd>SPARQL query</dd>
</dl>
<h2 id="return">Return</h2>
<p>set </p>
<pre><code>Query results.
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def query_graph(graph, q):
    &#34;&#34;&#34;
    Query rdflib.Graph. 
    Args:
        graph : rdflib.Graph \n
        q : str \n
            SPARQL query
    Return:
        set \n
            Query results.
    &#34;&#34;&#34;
    try:
        return set(graph.query(q))
    except Exception as e:
        print(e.message)
        return set()</code></pre>
</details>
</dd>
<dt id="tera.utils.strip_namespace"><code class="name flex">
<span>def <span class="ident">strip_namespace</span></span>(<span>string, var=['/'])</span>
</code></dt>
<dd>
<section class="desc"><p>Remove namespace from URI.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>string</code></strong> :&ensp;<code>str</code></dt>
<dd>URI</dd>
<dt><strong><code>var</code></strong> :&ensp;<code>str</code> or <code>list</code></dt>
<dd>Symbols to split string. ex. / or #.</dd>
</dl>
<h2 id="return">Return</h2>
<p>str </p>
<pre><code>Shortest remaining string after var.
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strip_namespace(string, var = [&#39;/&#39;]):
    &#34;&#34;&#34;
    Remove namespace from URI.
    Args:
        string : str \n
            URI \n
        var : str or list \n
            Symbols to split string. ex. / or #.
    Return:
        str \n
            Shortest remaining string after var.
    &#34;&#34;&#34;
    if not isinstance(var,list):
        var = [var]
    tmp1 = str(string)
    for v in var:
        tmp2 = str(string).split(v)[-1]
        if len(tmp2) &lt; len(tmp1):
            tmp1 = tmp2
    return tmp1</code></pre>
</details>
</dd>
<dt id="tera.utils.tanimoto"><code class="name flex">
<span>def <span class="ident">tanimoto</span></span>(<span>fp1, fp2)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculate tanimoto similarity between two chemical fingerprints.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fp1</code></strong> :&ensp;<code>str</code></dt>
<dd>Chemical fingerprint on binary form.</dd>
<dt><strong><code>fp2</code></strong> :&ensp;<code>str</code></dt>
<dd>Chemical fingerprint on binary form.</dd>
</dl>
<h2 id="return">Return</h2>
<dl>
<dt><strong><code>simiarity</code></strong> :&ensp;<code>float</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tanimoto(fp1, fp2):
    &#34;&#34;&#34;
    Calculate tanimoto similarity between two chemical fingerprints.
    Args:
        fp1 : str \n
            Chemical fingerprint on binary form.\n
        fp2 : str \n
            Chemical fingerprint on binary form.\n
    Return:
        simiarity : float
    &#34;&#34;&#34;
    fp1_count = fp1.count(&#39;1&#39;)
    fp2_count = fp2.count(&#39;1&#39;)
    both_count = (fp1 &amp; fp2).count(&#39;1&#39;)
    return float(both_count) / (fp1_count + fp2_count - both_count)</code></pre>
</details>
</dd>
<dt id="tera.utils.test_endpoint"><code class="name flex">
<span>def <span class="ident">test_endpoint</span></span>(<span>endpoint)</span>
</code></dt>
<dd>
<section class="desc"><p>Test SPARQL endpoint.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>endpoint</code></strong> :&ensp;<code>str</code></dt>
<dd>SPARQL endpoint URL. ex: <a href="https://query.wikidata.org/sparql">https://query.wikidata.org/sparql</a>
Return:</dd>
</dl>
<p>bool </p>
<pre><code>If endpoint returns data.
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_endpoint(endpoint):
    &#34;&#34;&#34;
    Test SPARQL endpoint.
    Args:
        endpoint : str \n
            SPARQL endpoint URL. ex: https://query.wikidata.org/sparql \
    Return:
        bool \n
            If endpoint returns data.
    &#34;&#34;&#34;
    sparql = SPARQLWrapper(endpoint)
    q = &#34;&#34;&#34;
        SELECT ?s ?p ?o
        WHERE {?s ?p ?o}
        LIMIT 100
    &#34;&#34;&#34; 

    sparql.setQuery(q)
    sparql.setReturnFormat(JSON)
    try:
        results = sparql.query().convert()
        return True
    except:
        return False</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tera" href="index.html">tera</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tera.utils.do_recursively_in_class" href="#tera.utils.do_recursively_in_class">do_recursively_in_class</a></code></li>
<li><code><a title="tera.utils.graph_to_dict" href="#tera.utils.graph_to_dict">graph_to_dict</a></code></li>
<li><code><a title="tera.utils.prefixes" href="#tera.utils.prefixes">prefixes</a></code></li>
<li><code><a title="tera.utils.query_endpoint" href="#tera.utils.query_endpoint">query_endpoint</a></code></li>
<li><code><a title="tera.utils.query_graph" href="#tera.utils.query_graph">query_graph</a></code></li>
<li><code><a title="tera.utils.strip_namespace" href="#tera.utils.strip_namespace">strip_namespace</a></code></li>
<li><code><a title="tera.utils.tanimoto" href="#tera.utils.tanimoto">tanimoto</a></code></li>
<li><code><a title="tera.utils.test_endpoint" href="#tera.utils.test_endpoint">test_endpoint</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>