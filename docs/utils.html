<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>tera.utils API documentation</title>
<meta name="description" content="Utilities used by other modules." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tera.utils</code></h1>
</header>
<section id="section-intro">
<p>Utilities used by other modules.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Utilities used by other modules.
&#34;&#34;&#34;
from SPARQLWrapper import SPARQLWrapper, JSON
from functools import wraps
from rdflib import Literal
from collections import defaultdict
import warnings
from tqdm import tqdm
from quantulum3 import parser 
from itertools import combinations

nan_values = [&#39;nan&#39;, float(&#39;nan&#39;),&#39;--&#39;,&#39;-X&#39;,&#39;NA&#39;,&#39;NC&#39;,-1,&#39;&#39;,&#39;sp.&#39;, -1,&#39;sp,&#39;,&#39;var.&#39;,&#39;variant&#39;,&#39;NR&#39;]

unit_lookup = defaultdict(lambda: &#39;&#39;)

unit_lookup.update({&#39;mg&#39;:&#39;Milligram&#39;,
                    &#39;ug&#39;: &#39;Microgram&#39;,
                    &#39;kg&#39;:&#39;Kilogram&#39;,
                    &#39;mM&#39;:&#39;Millimol&#39;,
                    &#39;ng&#39;:&#39;Nanogram&#39;,
                    &#39;g&#39;:&#39;Gram&#39;,
                    &#39;Âµg&#39;:&#39;Microgram&#39;,
                    &#39;L&#39;:&#39;Litre&#39;,
                    &#39;%&#39;:&#39;Percent&#39;,
                    &#39;cm&#39;:&#39;Centimetre&#39;,
                    &#39;mm&#39;:&#39;Millimetre&#39;,
                    &#39;nm&#39;:&#39;Nanometre&#39;,
                    &#39;deg&#39;:&#39;Degree&#39;,
                    &#39;C&#39;:&#39;Celcius&#39;,
                    &#39;K&#39;:&#39;Kelvin&#39;,
                    &#39;l&#39;:&#39;Litre&#39;,
                    &#39;psu&#39;:&#39;PracticalSalinityUnit&#39;,
                    &#39;h&#39;:&#39;Hour&#39;,
                    &#39;d&#39;:&#39;Day&#39;,
                    &#39;w&#39;:&#39;Week&#39;
                    }
                   )

prefix_table = {&#39;kilo&#39;:1000,
                &#39;hekto&#39;:100,
                &#39;deka&#39;:10,
                &#39;desi&#39;:0.1,
                &#39;centi&#39;:0.01,
                &#39;milli&#39;:1e-3,
                &#39;micro&#39;:1e-6,
                &#39;nano&#39;:1e-9,
                &#39;percent&#39;:0.01}

base_units = [&#39;gram&#39;,&#39;mol&#39;,&#39;litre&#39;,&#39;metre&#39;]

def unit_parser(string):
    &#34;&#34;&#34;
    Takes a unit string and converts to UNIT namespace string. 
    eg. mg/L -&gt; MilligramPerLitre
    Filters out assumed missprints, eg. mg%/L -&gt; MilligramPerLitre.
    
    Parameters
    ----------
    string : str
        Unit string.
    
    Returns
    -------
    str 
    
    Raises
    ------
    &#34;&#34;&#34;
    if len(string) &lt; 2 and string not in unit_lookup:
        return &#39;&#39;
    
    if &#39;dm^3&#39; in string:
        string.replace(&#39;dm^3&#39;,&#39;L&#39;)
    if &#39;dm3&#39; in string:
        string.replace(&#39;dm3&#39;,&#39;L&#39;)
    
    for elem,name in zip([&#39;/&#39;,&#39;^2&#39;,&#39;^3&#39;,&#39; &#39;],[&#39;Per&#39;,&#39;Squared&#39;,&#39;Cubed&#39;,&#39;&#39;]):
        if elem in string:
            a,b = string.split(elem, 1)
            return unit_parser(a) + name + unit_parser(b)
    
    if &#39;-1&#39; in string:
        return unit_parser(string.replace(&#39;-1&#39;,&#39;/&#39;))
    
    if string in unit_lookup:
        return unit_lookup[string]
    
    else:
        res1 = [string[x:y] for x, y in combinations(range(len(string) + 1), r = 2)]
        res1.remove(string)
        res2 = map(unit_parser, res1)
        res = zip(res2,res1)
        res = [(a,b) for a,b in res if len(a) &gt; 1]
        if res:
            u,_ = sorted(res, key=lambda x:len(x[1]),reverse=True).pop(0)
            return u
    
    return &#39;&#39;

def _units_of_same_type(unit1, unit2):
    unit1 = unit1.lower()
    unit2 = unit2.lower()
    
    for prefix in [&#39;milli&#39;,&#39;nano&#39;,&#39;micro&#39;,&#39;kilo&#39;,&#39;centi&#39;]:
        unit1 = unit1.replace(prefix,&#39;&#39;)
        unit2 = unit2.replace(prefix,&#39;&#39;)
    
    unit1 = unit1.replace(&#39;mol&#39;,&#39;gram&#39;)
    unit2 = unit2.replace(&#39;mol&#39;,&#39;gram&#39;)
    
    if &#39;per&#39; in unit1 and &#39;per&#39; in unit2:
        a1,b1 = unit1.split(&#39;per&#39;,1)
        a2,b2 = unit2.split(&#39;per&#39;,1)
        return _units_of_same_type(a1,a2) and _units_of_same_type(b1,b2)
    
    if unit1 == unit2:
        return True
    
    return False

def _to_base_unit(unit):
    
    unit = unit.lower()
    if unit in base_units:
        return 1
    
    if &#39;per&#39; in unit:
        a,b = unit.split(&#39;per&#39;,1)
        return _to_base_unit(a) / _to_base_unit(b)
    
    if &#39;squared&#39; in unit:
        a,b = unit.split(&#39;squared&#39;,1)
        return _to_base_unit(a)**2 * _to_base_unit(b)
    
    if &#39;cubed&#39; in unit:
        a,b = unit.split(&#39;cubed&#39;,1)
        return _to_base_unit(a)**3 * _to_base_unit(b)
    
    if unit in prefix_table:
        return prefix_table[unit]
    
    tmp = unit
    for bs in base_units:
        unit = unit.replace(bs,&#39;&#39;)
    if unit != tmp:
        return _to_base_unit(unit)
    
    return 0

def unit_conversion(from_unit, to_unit, molecular_mass=None):
    &#34;&#34;&#34;
    Calculates the conversion factor from one unit to another.
    
    Parameters
    ----------
    from_unit : URIRef 
    
    to_unit : URIRef
    
    molecular_mass : float 
        If converting to or from MOL this is needed.
    
    Returns
    -------
    factor : float
        The conversion ratio between from_unit and to_unit.
        new_scalar = old_scalar*factor . 
        Returns 0 if no conversion is found.
    
    Raises
    ------
    AssertionError:
        * If from_unit and to_unit is not on the same form. eg. MillimolPerLitre and MillimetrePerLiter raises error, while MillimolPerLitre and MilligramPerLiter does not.
        * If either unit contails mol, without input of molecular_mass.
    
    KeyError:
        * If conversion is not in prefix table.
    &#34;&#34;&#34;
    if from_unit == to_unit:
        return 1
    
    from_unit = strip_namespace(from_unit,[&#39;/&#39;,&#39;#&#39;])
    to_unit = strip_namespace(to_unit,[&#39;/&#39;,&#39;#&#39;])
    
    assert _units_of_same_type(from_unit, to_unit)
    
    from_unit = from_unit.lower()
    to_unit = to_unit.lower()
    mm_f = 1
    mm_t = 1
    
    if &#39;mol&#39; in from_unit:
        assert molecular_mass
        mm_f = molecular_mass
        from_unit = from_unit.replace(&#39;mol&#39;,&#39;gram&#39;)
        
    if &#39;mol&#39; in to_unit:
        assert molecular_mass
        mm_t = molecular_mass
        to_unit = to_unit.replace(&#39;mol&#39;,&#39;gram&#39;)
        
    return (mm_f * _to_base_unit(from_unit)) / (mm_t * _to_base_unit(to_unit))
        

def tanimoto(fp1, fp2):
    &#34;&#34;&#34;
    Calculate tanimoto similarity between two chemical fingerprints.
    
    Parameters 
    ----------
    fp1 : str
        Chemical fingerprint on binary form.
        
    fp2 : str
        Chemical fingerprint on binary form.
    
    Returns
    -------
    float
    &#34;&#34;&#34;
    fp1_count = fp1.count(&#39;1&#39;)
    fp2_count = fp2.count(&#39;1&#39;)
    both_count = (fp1 &amp; fp2).count(&#39;1&#39;)
    return float(both_count) / (fp1_count + fp2_count - both_count)


def test_endpoint(endpoint):
    &#34;&#34;&#34;
    Test SPARQL endpoint.
    
    Parameters 
    ----------
    endpoint : str 
        SPARQL endpoint URL. ex: https://query.wikidata.org/sparql 
    
    Returns
    -------
    bool
    &#34;&#34;&#34;
    sparql = SPARQLWrapper(endpoint)
    q = &#34;&#34;&#34;
        SELECT ?s ?p ?o
        WHERE {?s ?p ?o}
        LIMIT 100
    &#34;&#34;&#34; 

    sparql.setQuery(q)
    sparql.setReturnFormat(JSON)
    try:
        results = sparql.query().convert()
        return True
    except:
        return False
    
    
def query_endpoint(endpoint, q, var = &#39;p&#39;):
    &#34;&#34;&#34;
    Wrapper for quering SPARQL endpoint with SPARQLWrapper.
    
    Parameters 
    ----------
    endpoint : str
        SPARQL endpoint URL. 
    
    q : str 
        SPARQL query. 
        
    var : str or list 
        Query variables to return.
    
    Returns
    -------
    set 
        Set of tuple query results. Tuple in order specified in input var. 
    &#34;&#34;&#34;
    if not isinstance(var, list):
        var = [var]
        
    sparql = SPARQLWrapper(endpoint)
    
    out = {}
    try:
        sparql.setQuery(q)
        sparql.setReturnFormat(JSON)
        results = sparql.query().convert()
        for v in var:
            try:
                out[v] = [r[v][&#39;value&#39;] for r in results[&#39;results&#39;][&#39;bindings&#39;]]
            except KeyError:
                out[v] = [None] * len(results[&#39;results&#39;][&#39;bindings&#39;])
        return set(zip(*[out[k] for k in out]))
    except Exception as e:
        print(e)
        warnings.warn(&#39;Query failed:\n&#39; + q, UserWarning)
        return set()


def query_graph(graph, q):
    &#34;&#34;&#34;
    Query rdflib.Graph. 
    
    Parameters 
    ----------
    graph : rdflib.Graph 
    
    q : str 
        SPARQL query
   
    Returns
    -------
    set 
    &#34;&#34;&#34;
    try:
        return set(graph.query(q))
    except Exception as e:
        return set()

def prefixes(initNs):
    &#34;&#34;&#34;
    Format prefixes for SPARQL. 
    
    Parameters 
    ----------
    initNs : dict 
        ex : {&#39;ex&#39;:&#39;http://example.org&#39;} 
    
    Returns
    -------
    str 
    &#34;&#34;&#34;
    q = &#39;&#39;
    for k,i in initNs.items():
        q += &#34;PREFIX\t&#34;+k+&#39;:\t&#39; + &#39;&lt;&#39;+str(i)+&#39;&gt;\n&#39;
    return q

def strip_namespace(string, var = [&#39;/&#39;]):
    &#34;&#34;&#34;
    Remove namespace from URI.
    
    Parameters 
    ----------
    string : str 
        URI 
    var : str or list 
        Symbols to split string. ex. / or #.
    
    Returns
    -------
    str
    &#34;&#34;&#34;
    if not isinstance(var,list):
        var = [var]
    tmp1 = str(string)
    for v in var:
        tmp2 = str(string).split(v)[-1]
        if len(tmp2) &lt; len(tmp1):
            tmp1 = tmp2
    return tmp1

def do_recursively_in_class(func):
    &#34;&#34;&#34;Enables function to take either element or iterable as input.
    
    Returns
    -------
    function
    &#34;&#34;&#34;
    @wraps(func)
    def call_recursively(my_class_instance, x, **kwargs):
        if isinstance(x, (list,set,tuple)):
            f = lambda x: func(my_class_instance, x, **kwargs)
            out = {}
            pbar = lambda x: x
            if hasattr(my_class_instance, &#39;verbose&#39;):
                if my_class_instance.verbose:
                    pbar = lambda x: tqdm(x)
            return dict(zip(x,map(f,pbar(x))))
        else:
            return func(my_class_instance, x, **kwargs)
        
    return call_recursively


def graph_to_dict(graph):
    &#34;&#34;&#34;
    Map entities in graph to a dict.
    
    Parameters 
    ----------
    graph : rdflib.Graph
    
    Returns
    -------
    dict 
        On the form {entity : list of literals connected to entity}
    &#34;&#34;&#34;
    entities = graph.subjects()
    d = defaultdict(list)
    
    for e in entities:
        d[e] = [str(o) for o in graph.objects(subject=e) if isinstance(o,Literal)]
    return d</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tera.utils.do_recursively_in_class"><code class="name flex">
<span>def <span class="ident">do_recursively_in_class</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"><p>Enables function to take either element or iterable as input.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>function</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_recursively_in_class(func):
    &#34;&#34;&#34;Enables function to take either element or iterable as input.
    
    Returns
    -------
    function
    &#34;&#34;&#34;
    @wraps(func)
    def call_recursively(my_class_instance, x, **kwargs):
        if isinstance(x, (list,set,tuple)):
            f = lambda x: func(my_class_instance, x, **kwargs)
            out = {}
            pbar = lambda x: x
            if hasattr(my_class_instance, &#39;verbose&#39;):
                if my_class_instance.verbose:
                    pbar = lambda x: tqdm(x)
            return dict(zip(x,map(f,pbar(x))))
        else:
            return func(my_class_instance, x, **kwargs)
        
    return call_recursively</code></pre>
</details>
</dd>
<dt id="tera.utils.graph_to_dict"><code class="name flex">
<span>def <span class="ident">graph_to_dict</span></span>(<span>graph)</span>
</code></dt>
<dd>
<div class="desc"><p>Map entities in graph to a dict.</p>
<h2 id="parameters">Parameters</h2>
<p>graph : rdflib.Graph</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict </code></dt>
<dd>On the form {entity : list of literals connected to entity}</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def graph_to_dict(graph):
    &#34;&#34;&#34;
    Map entities in graph to a dict.
    
    Parameters 
    ----------
    graph : rdflib.Graph
    
    Returns
    -------
    dict 
        On the form {entity : list of literals connected to entity}
    &#34;&#34;&#34;
    entities = graph.subjects()
    d = defaultdict(list)
    
    for e in entities:
        d[e] = [str(o) for o in graph.objects(subject=e) if isinstance(o,Literal)]
    return d</code></pre>
</details>
</dd>
<dt id="tera.utils.prefixes"><code class="name flex">
<span>def <span class="ident">prefixes</span></span>(<span>initNs)</span>
</code></dt>
<dd>
<div class="desc"><p>Format prefixes for SPARQL. </p>
<h2 id="parameters">Parameters</h2>
<p>initNs : dict
ex : {'ex':'http://example.org'} </p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prefixes(initNs):
    &#34;&#34;&#34;
    Format prefixes for SPARQL. 
    
    Parameters 
    ----------
    initNs : dict 
        ex : {&#39;ex&#39;:&#39;http://example.org&#39;} 
    
    Returns
    -------
    str 
    &#34;&#34;&#34;
    q = &#39;&#39;
    for k,i in initNs.items():
        q += &#34;PREFIX\t&#34;+k+&#39;:\t&#39; + &#39;&lt;&#39;+str(i)+&#39;&gt;\n&#39;
    return q</code></pre>
</details>
</dd>
<dt id="tera.utils.query_endpoint"><code class="name flex">
<span>def <span class="ident">query_endpoint</span></span>(<span>endpoint, q, var='p')</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper for quering SPARQL endpoint with SPARQLWrapper.</p>
<h2 id="parameters">Parameters</h2>
<p>endpoint : str
SPARQL endpoint URL. </p>
<p>q : str
SPARQL query. </p>
<p>var : str or list
Query variables to return.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>set </code></dt>
<dd>Set of tuple query results. Tuple in order specified in input var.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def query_endpoint(endpoint, q, var = &#39;p&#39;):
    &#34;&#34;&#34;
    Wrapper for quering SPARQL endpoint with SPARQLWrapper.
    
    Parameters 
    ----------
    endpoint : str
        SPARQL endpoint URL. 
    
    q : str 
        SPARQL query. 
        
    var : str or list 
        Query variables to return.
    
    Returns
    -------
    set 
        Set of tuple query results. Tuple in order specified in input var. 
    &#34;&#34;&#34;
    if not isinstance(var, list):
        var = [var]
        
    sparql = SPARQLWrapper(endpoint)
    
    out = {}
    try:
        sparql.setQuery(q)
        sparql.setReturnFormat(JSON)
        results = sparql.query().convert()
        for v in var:
            try:
                out[v] = [r[v][&#39;value&#39;] for r in results[&#39;results&#39;][&#39;bindings&#39;]]
            except KeyError:
                out[v] = [None] * len(results[&#39;results&#39;][&#39;bindings&#39;])
        return set(zip(*[out[k] for k in out]))
    except Exception as e:
        print(e)
        warnings.warn(&#39;Query failed:\n&#39; + q, UserWarning)
        return set()</code></pre>
</details>
</dd>
<dt id="tera.utils.query_graph"><code class="name flex">
<span>def <span class="ident">query_graph</span></span>(<span>graph, q)</span>
</code></dt>
<dd>
<div class="desc"><p>Query rdflib.Graph. </p>
<h2 id="parameters">Parameters</h2>
<p>graph : rdflib.Graph </p>
<p>q : str
SPARQL query</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>set</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def query_graph(graph, q):
    &#34;&#34;&#34;
    Query rdflib.Graph. 
    
    Parameters 
    ----------
    graph : rdflib.Graph 
    
    q : str 
        SPARQL query
   
    Returns
    -------
    set 
    &#34;&#34;&#34;
    try:
        return set(graph.query(q))
    except Exception as e:
        return set()</code></pre>
</details>
</dd>
<dt id="tera.utils.strip_namespace"><code class="name flex">
<span>def <span class="ident">strip_namespace</span></span>(<span>string, var=['/'])</span>
</code></dt>
<dd>
<div class="desc"><p>Remove namespace from URI.</p>
<h2 id="parameters">Parameters</h2>
<p>string : str
URI
var : str or list
Symbols to split string. ex. / or #.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strip_namespace(string, var = [&#39;/&#39;]):
    &#34;&#34;&#34;
    Remove namespace from URI.
    
    Parameters 
    ----------
    string : str 
        URI 
    var : str or list 
        Symbols to split string. ex. / or #.
    
    Returns
    -------
    str
    &#34;&#34;&#34;
    if not isinstance(var,list):
        var = [var]
    tmp1 = str(string)
    for v in var:
        tmp2 = str(string).split(v)[-1]
        if len(tmp2) &lt; len(tmp1):
            tmp1 = tmp2
    return tmp1</code></pre>
</details>
</dd>
<dt id="tera.utils.tanimoto"><code class="name flex">
<span>def <span class="ident">tanimoto</span></span>(<span>fp1, fp2)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate tanimoto similarity between two chemical fingerprints.</p>
<h2 id="parameters">Parameters</h2>
<p>fp1 : str
Chemical fingerprint on binary form.</p>
<p>fp2 : str
Chemical fingerprint on binary form.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tanimoto(fp1, fp2):
    &#34;&#34;&#34;
    Calculate tanimoto similarity between two chemical fingerprints.
    
    Parameters 
    ----------
    fp1 : str
        Chemical fingerprint on binary form.
        
    fp2 : str
        Chemical fingerprint on binary form.
    
    Returns
    -------
    float
    &#34;&#34;&#34;
    fp1_count = fp1.count(&#39;1&#39;)
    fp2_count = fp2.count(&#39;1&#39;)
    both_count = (fp1 &amp; fp2).count(&#39;1&#39;)
    return float(both_count) / (fp1_count + fp2_count - both_count)</code></pre>
</details>
</dd>
<dt id="tera.utils.test_endpoint"><code class="name flex">
<span>def <span class="ident">test_endpoint</span></span>(<span>endpoint)</span>
</code></dt>
<dd>
<div class="desc"><p>Test SPARQL endpoint.</p>
<h2 id="parameters">Parameters</h2>
<p>endpoint : str
SPARQL endpoint URL. ex: <a href="https://query.wikidata.org/sparql">https://query.wikidata.org/sparql</a> </p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_endpoint(endpoint):
    &#34;&#34;&#34;
    Test SPARQL endpoint.
    
    Parameters 
    ----------
    endpoint : str 
        SPARQL endpoint URL. ex: https://query.wikidata.org/sparql 
    
    Returns
    -------
    bool
    &#34;&#34;&#34;
    sparql = SPARQLWrapper(endpoint)
    q = &#34;&#34;&#34;
        SELECT ?s ?p ?o
        WHERE {?s ?p ?o}
        LIMIT 100
    &#34;&#34;&#34; 

    sparql.setQuery(q)
    sparql.setReturnFormat(JSON)
    try:
        results = sparql.query().convert()
        return True
    except:
        return False</code></pre>
</details>
</dd>
<dt id="tera.utils.unit_conversion"><code class="name flex">
<span>def <span class="ident">unit_conversion</span></span>(<span>from_unit, to_unit, molecular_mass=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the conversion factor from one unit to another.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>from_unit</code></strong> :&ensp;<code>URIRef </code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>to_unit</code></strong> :&ensp;<code>URIRef</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>molecular_mass</code></strong> :&ensp;<code>float </code></dt>
<dd>If converting to or from MOL this is needed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>factor</code></strong> :&ensp;<code>float</code></dt>
<dd>The conversion ratio between from_unit and to_unit.
new_scalar = old_scalar*factor .
Returns 0 if no conversion is found.</dd>
</dl>
<h2 id="raises">Raises</h2>
<h2 id="assertionerror">Assertionerror</h2>
<ul>
<li>If from_unit and to_unit is not on the same form. eg. MillimolPerLitre and MillimetrePerLiter raises error, while MillimolPerLitre and MilligramPerLiter does not.</li>
<li>If either unit contails mol, without input of molecular_mass.</li>
</ul>
<h2 id="keyerror">Keyerror</h2>
<ul>
<li>If conversion is not in prefix table.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unit_conversion(from_unit, to_unit, molecular_mass=None):
    &#34;&#34;&#34;
    Calculates the conversion factor from one unit to another.
    
    Parameters
    ----------
    from_unit : URIRef 
    
    to_unit : URIRef
    
    molecular_mass : float 
        If converting to or from MOL this is needed.
    
    Returns
    -------
    factor : float
        The conversion ratio between from_unit and to_unit.
        new_scalar = old_scalar*factor . 
        Returns 0 if no conversion is found.
    
    Raises
    ------
    AssertionError:
        * If from_unit and to_unit is not on the same form. eg. MillimolPerLitre and MillimetrePerLiter raises error, while MillimolPerLitre and MilligramPerLiter does not.
        * If either unit contails mol, without input of molecular_mass.
    
    KeyError:
        * If conversion is not in prefix table.
    &#34;&#34;&#34;
    if from_unit == to_unit:
        return 1
    
    from_unit = strip_namespace(from_unit,[&#39;/&#39;,&#39;#&#39;])
    to_unit = strip_namespace(to_unit,[&#39;/&#39;,&#39;#&#39;])
    
    assert _units_of_same_type(from_unit, to_unit)
    
    from_unit = from_unit.lower()
    to_unit = to_unit.lower()
    mm_f = 1
    mm_t = 1
    
    if &#39;mol&#39; in from_unit:
        assert molecular_mass
        mm_f = molecular_mass
        from_unit = from_unit.replace(&#39;mol&#39;,&#39;gram&#39;)
        
    if &#39;mol&#39; in to_unit:
        assert molecular_mass
        mm_t = molecular_mass
        to_unit = to_unit.replace(&#39;mol&#39;,&#39;gram&#39;)
        
    return (mm_f * _to_base_unit(from_unit)) / (mm_t * _to_base_unit(to_unit))</code></pre>
</details>
</dd>
<dt id="tera.utils.unit_parser"><code class="name flex">
<span>def <span class="ident">unit_parser</span></span>(<span>string)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes a unit string and converts to UNIT namespace string.
eg. mg/L -&gt; MilligramPerLitre
Filters out assumed missprints, eg. mg%/L -&gt; MilligramPerLitre.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>string</code></strong> :&ensp;<code>str</code></dt>
<dd>Unit string.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str </code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unit_parser(string):
    &#34;&#34;&#34;
    Takes a unit string and converts to UNIT namespace string. 
    eg. mg/L -&gt; MilligramPerLitre
    Filters out assumed missprints, eg. mg%/L -&gt; MilligramPerLitre.
    
    Parameters
    ----------
    string : str
        Unit string.
    
    Returns
    -------
    str 
    
    Raises
    ------
    &#34;&#34;&#34;
    if len(string) &lt; 2 and string not in unit_lookup:
        return &#39;&#39;
    
    if &#39;dm^3&#39; in string:
        string.replace(&#39;dm^3&#39;,&#39;L&#39;)
    if &#39;dm3&#39; in string:
        string.replace(&#39;dm3&#39;,&#39;L&#39;)
    
    for elem,name in zip([&#39;/&#39;,&#39;^2&#39;,&#39;^3&#39;,&#39; &#39;],[&#39;Per&#39;,&#39;Squared&#39;,&#39;Cubed&#39;,&#39;&#39;]):
        if elem in string:
            a,b = string.split(elem, 1)
            return unit_parser(a) + name + unit_parser(b)
    
    if &#39;-1&#39; in string:
        return unit_parser(string.replace(&#39;-1&#39;,&#39;/&#39;))
    
    if string in unit_lookup:
        return unit_lookup[string]
    
    else:
        res1 = [string[x:y] for x, y in combinations(range(len(string) + 1), r = 2)]
        res1.remove(string)
        res2 = map(unit_parser, res1)
        res = zip(res2,res1)
        res = [(a,b) for a,b in res if len(a) &gt; 1]
        if res:
            u,_ = sorted(res, key=lambda x:len(x[1]),reverse=True).pop(0)
            return u
    
    return &#39;&#39;</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tera" href="index.html">tera</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tera.utils.do_recursively_in_class" href="#tera.utils.do_recursively_in_class">do_recursively_in_class</a></code></li>
<li><code><a title="tera.utils.graph_to_dict" href="#tera.utils.graph_to_dict">graph_to_dict</a></code></li>
<li><code><a title="tera.utils.prefixes" href="#tera.utils.prefixes">prefixes</a></code></li>
<li><code><a title="tera.utils.query_endpoint" href="#tera.utils.query_endpoint">query_endpoint</a></code></li>
<li><code><a title="tera.utils.query_graph" href="#tera.utils.query_graph">query_graph</a></code></li>
<li><code><a title="tera.utils.strip_namespace" href="#tera.utils.strip_namespace">strip_namespace</a></code></li>
<li><code><a title="tera.utils.tanimoto" href="#tera.utils.tanimoto">tanimoto</a></code></li>
<li><code><a title="tera.utils.test_endpoint" href="#tera.utils.test_endpoint">test_endpoint</a></code></li>
<li><code><a title="tera.utils.unit_conversion" href="#tera.utils.unit_conversion">unit_conversion</a></code></li>
<li><code><a title="tera.utils.unit_parser" href="#tera.utils.unit_parser">unit_parser</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>